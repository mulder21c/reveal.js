<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>접근 가능한 레이어팝업 만들기</title>

    <link rel="stylesheet" href="lib/font/source-sans-pro/source-sans-pro.css" />
    <link rel="stylesheet" href="lib/css/spoqa-han-sans-kr.css" />
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="plugin/prismjs/prism.min.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
          <h1><span class="non-break">접근 가능한 레이어팝업</span><small class="non-break">feat. WAI-ARIA</small></h1>
          <p data-align="right">
            콘텐츠연합플랫폼 <br>
            클라이언트개발부 지성봉
          </p>
        </section>
        <section>
          <section>
            <h2 class="heading3">Modal Window</h2>
            <img src="images/layerpopup.jpg" alt="modal window layer popup 예제" class="stretch" />
            <aside class="notes">
              이런 팝업 많이 쓰시죠? <br>
              무언가 액션이 일어나면 딤드 처리하고 레이어를 띄우는 팝업. 레이어 팝업이라고도 부르지만, 좀 더 공학적인 단어로 말해보면 이러한 형태를 두고 모달 윈도우라고 부릅니다.
            </aside>
          </section>
          <section>
            <dl>
              <dt>Modal Window</dt>
              <dd>
                 사용자 인터페이스 디자인 개념에서 자식 윈도에서 부모 윈도로 돌아가기 전에 사용자의 
                 상호동작을 요구하는 창. 응용 프로그램의 메인 창의 작업 흐름을 방해한다. 
              </dd>
            </dl>
            <aside class="notes">
              modal window의 정의를 찾아보면 위키 백과에 이렇게 설명이 되어 있습니다. <br>
              왜 이걸 들고 왔을까요?
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3>native HTML의 한계점</h3>
            <ul>
              <li class="fragment">팝업이 떴다라는 정보를 인지할 수 없다.</li>
              <li class="fragment">팝업 이외의 문서 정보에 접근이 된다.</li>
              <li class="fragment">키보드 <kbd>tab</kbd>키 운용이 팝업을 벗어난다.</li>
              <li class="fragment">키보드 트랩 문제 (IE8 ~ 10)</li>
            </ul>
            <aside class="notes">
              네 무언가 문제가 있기 때문이겠죠? (클릭) <br>
              native language 만으로 레이어 팝업을 구성했을 때 어떤 문제점이 있을까요? (하나씩 확인)<br>
              실제로 그러한지 영상을 통해 확인해보도록 하겠습니다.
            </aside>
          </section>
          <section>
            <video class="stretch" controls controlslist="nodownload">
              <source src="movie/screenreader2.mp4" type="video/mp4">
            </video>
            <aside class="notes">
              일단 브라우즈 모드로 쭉 읽어 내려가구요. 
              엔터키를 눌러 팝업을 열어보겠습니다. <br />
              화면상에서는 팝업이 열렸는데 스크린리더 상으로는 무슨 일이 일어났는지 전혀 알수가 없죠. <br />
              가상 커서를 계속 이동시켜 보겠습니다. 팝업 내용에 접근이 되죠. <br />
              다시 거꾸로 가상 커서를 다시 이동시켜 보겠습니다. <br />
              레이어 팝업을 벗어나는게 보이시죠? <br />
              이 상태에서 이번엔 탭 키를 눌러보도록 하겠습니다. <br />
              바닥에 있는 팝업 열기 버튼에 접근이 되는게 보이죠?
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>requirement</h2>
            <ul>
              <li class="fragment">팝업이 열렸을 때 팝업 내용 인식 가능</li>
              <li class="fragment">팝업 아래의 Windows는 비활성화</li>
              <li class="fragment"><kbd>tab</kbd>키 운용이 팝업 내부에서만 순환</li>
              <li class="fragment">팝업이 닫혔을 때 초점이 원래 있던 곳으로 반환</li>
            </ul>
            <aside class="notes">
              이러한 모달 윈도우 형태의 레이어 팝업에 대한 접근성의 요구사항을 알아보면, 
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>How to?</h2>
            <aside class="notes">
              그러면, 이 모달 윈도우 형태의 레이어 팝업을 어떻게 해야 접근성을 향상 시킬수 있는지를 단계별로 알아보도록 하겠습니다. <br>
              코드와 함께 설명을 드릴거니까요, JavaScript가 익숙하신 분들은 github에 제공되어 있는 코드를 내려받아서 따라오시면서 실습해보시면 좋을 것 같습니다. <br>
              WAI-ARIA role이나 속성들은 진행 단계에 따라서 설명을 드릴거기 때문에 한 눈에 정리된 내용은 슬라이드 마지막 장표를 참고하시면 되겠습니다.
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3 class="heading4">Step 1. 콘텐츠 역할 정의</h3>
            <p class="fragment">
              <code class="language-markup">role="dialog"</code>
            </p>
            <p class="fragment advisor">
              <span class="non-break">사용자가 정보를 입력하거나 응답할 것을 요구하도록</span> 
              <span class="non-break">유도하기 위해 </span>
              <span class="non-break">어플리케이션의 현재 처리를 중단시키도록 설계된</span> 
              <span class="non-break">어플리케이션 윈도우</span>
            </p>
            <aside class="notes">
              우선 가장 첫 단계는 모달 윈도우라는 정보를 제공하는 겁니다. (클릭)<br> 
              이 정보는 dialog role을 부여하기만 하면 되구요, dialog role이 부여하는 의미는 다음과 같습니다. (클릭) <br>
              코드에서 어떻게 적용하는지 볼까요?
            </aside>
          </section>
          <section>
            <pre><code class="language-markup">&lt;div class="popup-wrap">
  &lt;div class="popup-body" 
          <span class="fragment" data-fragment-index="0">role="dialog"</span>
          <span class="fragment" data-fragment-index="1">aria-labelledby="<mark class="fragment" data-fragment-index="2">pop-title</mark>"</span>>
    &lt;strong <mark class="fragment" data-fragment-index="2">id="pop-title"</mark> class="modal-header">접근 가능한 레이어 팝업&lt;/strong>
    &lt;div class="modal-body">
      &lt;p>
        접근 가능한 레이어 팝업이란?
      &lt;/p>
      ...</code></pre>
            <aside class="notes">
              일단 대화상자에 해당하는 요소에 role="dialog"를 부여하구요 (클릭) <br>
              dialog role을 부여하면 단순히 "대화상자"로 인식되기 때문에, 이 대화상자가 어떤 대화상자다라는 정보를 주기 위해 dialog role을 부여한 요소에 이름을 부여해서 구체화 할 필요가 있습니다. 이때 사용되는 것이 aria-label 혹은 aria-labelledby 속성이구요,(클릭) 여기에서는 대화상자의 제목에 해당하는 요소가 있기 때문에 이 요소에 id 속성을 사용해서 aria-labelledby 를 사용합니다. (클릭)
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3 class="heading4">Step 2. 팝업이 열릴 때 내용 인식</h3>
            <p class="fragment">
              대화 상자 내부로 초점 이동
            </p>
            <ul class="advisor">
              <li class="fragment">
                모든 상황에서 초점은 대화 상자 안에 있는 요소로 이동
              </li>
              <li class="fragment">
                첫 번째 초점을 얻을 수 있는 요소로 이동하는 것이 기본
              </li>
              <li class="fragment">
                <ul style="">
                  <li>
                    첫번째 포커스 가능한 요소로 초점을 이동시키는 것이 <br>
                    콘텐츠의 시작 부분을 스크롤 밖으로 밀어낼 경우
                  </li>
                  <li>대화상자 안에 초점을 받을 수 있는 요소가 없을 경우</li>
                </ul>
                정적 요소에 <code class="language-markup">tabindex="-1"</code>을 추가하여 이 요소로 초점 이동
              </li>
            </ul>
            <aside class="notes">
              두번째 단계로, 팝업이 열리면 사용자가 팝업이 열렸다라는 것을 인식할 수 있게 제공이 되어야 합니다. <br>
              이를 위해서는 대화 상자 내부로 초점을 이동시키면 되는데요. 이는 마치 시스템 팝업이 열렸을 때 초점이 해당 윈도우에 잡히는 것을 구현하는 겁니다. <br>
              단, 그냥 아무렇게나 하지는 않고 약간의 규칙이 있습니다. (클릭) ...  W3C 문서를 참고해보시면 좀더 자세한 내용을 보실 수 있습니다.
            </aside>
          </section>
          <section>
            <pre data-line="3"><code class="language-markup">&lt;div class="popup-wrap">
  &lt;div class="popup-body" role="dialog" aria-labelledby="pop-title">
    <span class="fragment">&lt;a class="placeholder" tabindex="-1">&lt;/a></span>
    &lt;strong id="pop-title" class="modal-header">접근 가능한 레이어 팝업&lt;/strong>
    &lt;div id="popup-contents" class="modal-body">
      &lt;p>
        접근 가능한 레이어 팝업이란?
      &lt;/p></code></pre>
            <aside class="notes">
              예제 코드에서는 주요 내용이 포커스를 얻을 수 있는 요소가 없기 때문에 정적 요소를 하나 두고 여기에 tabindex를 -1로 설정합니다. (클릭)
            </aside>
          </section>
          <section>
            <pre data-line="2,4"><code class="language-javascript">function openPopup () {
  <span class="fragment" data-fragment-index="0">var popupBody = document.querySelector(".popup-body");</span>
  document.documentElement.classList.add("on-popup");
  <span class="fragment" data-fragment-index="0">popupBody.querySelector(".placeholder").focus();</span>
}</code></pre>
            <aside class="notes">
              그리고 팝업이 오픈 될 때 방금 생성한 요소로 초점이 이동되도록 스크립트를 작성합니다.
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3 class="heading4">Step 3. 팝업 아래 Windows 비활성화</h3>
            <ul>
              <li class="fragment">Browse mode 진입 차단</li>
              <li class="fragment">대화 상자 내에서 tab 이동 순환</li>
            </ul>
            <aside class="notes">
              세번째 단계로, 이제 딤드 영역으로 마우스 인터랙션이 차단된 영역. 즉, 레이어팝업을 제외한 나머지 영역을 비활성화 하는 것인데요. 여기에는 크게 두가지 차단 요소가 있습니다. (클릭) 하나는 스크린리더의 브라우즈 모드로 진입되는 것을 차단해야 하는 것이고 (클릭) 하나는 tab 이동이 대화 상자 내에서만 순환되고 나머지 영역으로 이동되지 않아야 한다는 거죠.
            </aside>
          </section>
          <section>
            <h4>Browse mode 진입 차단</h4>
            <p class="fragment advisor" data-align="left" data-fragment-index="0">
              <code class="language-markup">role="dialog"</code>가 자동으로 처리 <br>
              단, NVDA 2017.4+, NVDA 2017.2 + FireFox, JAWS 18+ 등에서만 지원
            </p>
            <p class="fragment advisor" data-align="left" data-fragment-index="1">
              <code class="language-markup">aria-modal="true"</code> in ARIA 1.1 <br>
              iOS 10.x/10.2에서는 문제가 있는 것으로 리포트 됨 <br>(대화상자 제목과 지시사항들이 읽는 순서에 따라 접근 가능하지 않게 되는 문제 발생)
            </p>
            <aside class="notes">
              먼저 브라우즈 모드 진입을 차단하는 것을 보면, 사실 role="dialog"를 적용하면 현재 NVDA 2017.4버전과 JAWS 18버전은 자동으로 차단을 하고 있고, NVDA 2017.2 버전에 FF 조합일 경우에는 차단이 됩니다. 주요 major AT들의 최신버전들은 지원이 되는 반면 그 이전 버전이나 센스리더의 경우는 지원이 되지 않는 문제가 있습니다. <br>
              참고로 ARIA 1.1에 와서 aria-modal 속성이 생겼는데 이걸 추가하면 브라우즈 모드 자체를 modal로 동작하게 해서 차단시키는 기능인데, 앞서 말씀드린 스크린리더기들은 이 설정과 관계없이 지원을 하고 있구요, 단 iOS에서는 문제가 있다는 보고가 있습니다. 가급적이면 아직은 사용하지 않는것을 권장드립니다.
            </aside>
          </section>
          <section>
            <h4>Browse mode 진입 차단</h4>
            <p class="fragment advisor">
              차선책: 대화 상자 외 타 콘텐츠에 <code class="language-markup">aria-hidden="true"</code> 설정
            </p>
            <p class="fragment advisor">
              단, 마크업 순서에 따라 적용이 어려워지는 상황이 발생. <br>
              가급적 dialog 요소를 level 1 수준으로 위치시키는 것이 정신건강에 좋음
            </p>
            <aside class="notes">
              그러면, dialog role 만으로는 브라우즈 모드 탐색 차단이 안될 수 있다는 건데 방법이 없느냐? 차선책은 항상 있지요. (클릭) <br>
              대화 상자 외 나머지 콘텐츠를 aria-hidden="true"로 처리해서 스크린리더가 인식하지 못하게 하는 방법입니다. 단, 이렇게 할 경우 부모 요소는 aria-hidden이 true가 되지 않아야 하기 때문에 해당 요소의 위치에 따라 적용이 어려운 상황이 발생될 수 있습니다. <br>
              따라서 가급적 이 방식을 사용할 때에는 dialog를 최상위 수준에 위치시키는 것이 정신을 안정시켜줄 수 있습니다.
            </aside>
          </section>
          <section>
            <pre data-line="1-9,14"><code class="language-javascript"><span class="fragment" data-fragment-index="0">function setSiblingsHidden(currElem){
  var ommits = ["script", "meta", "link", "style", "base"];
  for(var i = -1, node; node = currElem.parentNode.children[++i];){
    if(node == currElem || ommits.indexOf(node.tagName.toLowerCase()) > -1) 
      continue;
    node.setAttribute("aria-hidden", "true");
    node.setAttribute("data-outside-modal", "true");
  }
}</span>
            
function openPopup(){
  var popupBody = document.querySelector(".popup-body");
  document.documentElement.classList.add("on-popup");
  <span class="fragment" data-fragment-index="0">setSiblingsHidden(document.querySelector(".popup-wrap"));</span>
  popupBody.querySelector(".placeholder").focus();
}</code></pre>
            <aside class="notes">
              코드에서 보면, 앞뒤 형제 요소들을 aria-hidden="true"처리를 하기 위해 setSiblingHidden 함수를 만들어서 popup을 오픈시키는 함수 내에 작성합니다. <br>
              그리고 한번 설정해 두었으면 팝업이 닫힐 때는 반대로 다시 해제 되어야 하겠죠?
            </aside>
          </section>
          <section>
            <pre data-line="1-9,14"><code class="language-javascript"><span class="fragment" data-fragment-index="0">function unsetSiblingsHidden(currElem){
  for(var i = -1, 
              node, 
              outsides= document.querySelectorAll("[data-outside-modal]"); 
              node = outsides[++i]; ) {
    node.removeAttribute("aria-hidden");
    node.removeAttribute("data-outside-modal");
  }
}</span>

function closePopup(event){
  event = event || window.event;  
  document.documentElement.classList.remove("on-popup");
  <span class="fragment" data-fragment-index="0">unsetSiblingsHidden();</span>
}</code></pre>
            <aside class="notes">
              그래서 다시 해제하는 코드를 팝업을 닫아주는 closePopup 함수에 작성합니다.
            </aside>
          </section>
          <section>
            <h4 class="heading4">대화 상자 내에서 tab 이동 순환</h4>
            <ul class="advisor">
              <li class="fragment">
                Tab 키
                <ul>
                  <li>
                    대화상자 내 다음 tabbable 요소로 이동
                  </li>
                  <li>
                    마지막 tabbable 요소에 있는 경우 포커스를 대화상자 내 첫 번째 tabbable 요소로 이동
                  </li>
                </ul>
              </li>
              <li class="fragment">
                SHFIT + Tab 키
                <ul>
                  <li>
                    대화상자 내 이전 tabbable 요소로 이동
                  </li>
                  <li>
                    첫번째 tabbable 요소에 있는 경우 포커스를 대화상자 내 마지막 tabbable 요소로 이동
                  </li>
                </ul>
              </li>
            </ul>
            <aside class="notes">
              tab 이동을 순환시키기 위해서는 두 가지 키스트로크에 대응을 해 주어야 합니다. <br>
              (클릭) tab 키를 운용할 경우에는 ... <br>
              (클릭) shift+tab키를 운용할 경우에는 ...
            </aside>
          </section>
          <section>
            <pre data-line="14-20"><code class="language-javascript">(function(){
  var focuslock = (function(){
    var firstElem, lastElem;
    return {
      setFirstBtn : function(el){
        firstElem = el;
      },
      setLastBtn : function(el){
        lastElem = el;
      },
      focuslockKeyDown : function(event){
        event = event || window.event;
        var keycode = event.which || event.keyCode;
        if(event.shiftKey && keycode === 9 && event.target === firstElem){
          event.preventDefault ? event.preventDefault() : event.returnValue = false;
          lastElem.focus();
        }else if(!event.shiftKey && keycode === 9 && event.target === lastElem){
          event.preventDefault ? event.preventDefault() : event.returnValue = false;
          firstElem.focus();
        }
      }
    };
  }());
  window.focuslock = window.focuslock || focuslock;
}());</code></pre>
            <aside class="notes">
              이 함수는 github에 focuslock.js 파일로 올라가 있구요, 중요한 부분만 설명을 드리면, 좀 전에 언급한 첫번째 요소에서 shift + tab 마지막 요소가 포커스 되고, 마지막 요소에서 tab 하면 첫번째 요소가 포커스 되는 코드입니다.
            </aside>
          </section>
          <section>
            <pre data-line="5-7"><code class="language-javascript">function openPopup(){
  var popupBody = document.querySelector(".popup-body");
  document.documentElement.classList.add("on-popup");

  <span class="fragment">focuslock.setFirstBtn(btnClosePopup);
  focuslock.setLastBtn(btnClosePopup);
  popupBody.addEventListener("keydown", focuslock.focuslockKeyDown);</span>

  setSiblingsHidden(document.querySelector(".popup-wrap"));
  popupBody.querySelector(".placeholder").focus();
}</code></pre>
            <aside class="notes">
              좀전의 함수를 이용해서, 대화 상자 내에서 탭이 순환되도록 이벤트를 추가합니다.
            </aside>
          </section>
          <section>
            <pre data-line="3,5"><code class="language-javascript">function closePopup(event){
  event = event || window.event;
  <span class="fragment" data-fragment-index="0">var popupBody = document.querySelector(".popup-body");</span>  
  document.documentElement.classList.remove("on-popup");
  <span class="fragment" data-fragment-index="0">popupBody.removeEventListener("keydown", focuslock.focuslockKeyDown);</span>
  unsetSiblingsHidden();
}</code></pre>
            <aside class="notes">
              열었을 때 이벤트를 추가했으니 닫을 때에는 이벤트를 삭제해주어야겠죠?
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3 class="heading4">Step 4. 키보드 트랩 방지</h3>
            <p class="fragment advisor">
              팝업이 열릴 때 초점이 얻어진 요소를 기억해 두었다가 팝업이 닫힐 때 해당 요소에 다시 초점 이동
            </p>
          </section>
          <section>
            <pre data-line="2,9,20"><code class="language-javascript">(function () {
  <span class="fragment" data-fragment-index="0">var focusedElem = null;</span>
  var btnOpenPopup = document.getElementById("open-popup");
  var btnClosePopup = document.getElementById("close-popup");
  ...
  function openPopup(){
    var popupBody = document.querySelector(".popup-body");
    document.documentElement.classList.add("on-popup");    
    <span class="fragment" data-fragment-index="0">focusedElem = this;</span>

    focuslock.setFirstBtn(btnClosePopup);
    focuslock.setLastBtn(btnClosePopup);
    popupBody.addEventListener("keydown", focuslock.focuslockKeyDown);
    ...
  }
  function closePopup(event){
    event = event || window.event;
    var popupBody = document.querySelector(".popup-body");
    ...
    <span class="fragment" data-fragment-index="0">focusedElem.focus();</span>
  }
}());</code></pre>
            <aside class="notes">
              이렇게, openPopup이 호출 될 때, 초점이 있던 요소를 기억해 두었다가, closePopup이 호출 될 때 그 요소로 초점을 주면 되겠죠.
              <br>
              이제 끝일까요? ㅎㅎ 한가지만 더 추가해볼게요. 
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3 class="heading4">Step 5. ESC 키를 눌렀을 때 팝업 닫기</h3>
            <aside class="notes">
              W3C WAI-ARIA Authoring Practices에서는 dialog에 대한 키보드 인터랙션으로 ESC키 역시도 정의를 하고 있구요, ESC를 눌렀을 경우에는 팝업이 닫혀야 한다라고 기술되어 있습니다. 이 부분을 마저 작성해보면
            </aside>
          </section>
          <section>
            <pre data-line="4,9-11,14"><code class="language-javascript">function openPopup(){
  ...

  <span class="fragment" data-fragment-index="0">document.addEventListener("keydown", closePopup);</span>
}

function closePopup(event){
  event = event || window.event;
  <span class="fragment" data-fragment-index="0">if(event.type === 'keydown' && event.keyCode !== 27){
    return;
  }</span>

  ...
  <span class="fragment" data-fragment-index="0">document.removeEventListener("keydown", closePopup);</span>
}</code></pre>
            <aside class="notes">
              popup을 띄울 때 document에 키 스트로크에 대한 이벤트를 추가하고, closePopup 함수에서 ESC키를 검출해서 ESC일 경우에만 팝업이 닫도록 처리를 하고, 닫힐 때에는 다시 이벤트를 해제하면 되겠습니다. <br>
              이렇게 해서 기능 개발이 완료 되었네요
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2 class="heading3">Used ARIA Role, Property</h2>
            <table class="fragment aria-describe">
              <colgroup>
                <col style="width: 30%;">
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th scope="col">Roles/Property</th>
                  <th scope="col">Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th scope="row"><var>dialog</var></th>
                  <td>사용자가 정보를 입력하거나 응답할 것을 요구하도록 유도하기 위해 어플리케이션의 현재 처리를 중단시키도록 설계된 어플리케이션 윈도우</td>
                </tr>
                <tr>
                  <th scope="row"><span class="non-break">aria-label</span> <span class="non-break">aria-labelledby</span></th>
                  <td>해당 객체의 label(이름)을 설정</td>
                </tr>
                <tr>
                  <th scope="row"><span class="non-break">aria-describe</span> <span class="non-break">aria-describedby</span></th>
                  <td>해당 객체에 대한 설명 추가</td>
                </tr>
              </tbody>
            </table>
          </section>
          <section>
            <h2 class="heading3">Keyboard Interaction</h2>
            <table class="fragment aria-describe">
              <colgroup>
                <col style="width: 30%;">
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th scope="col">Key</th>
                  <th scope="col">Behavior</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th scope="row"><kbd>Tab</kbd></th>
                  <td>
                    <ul>
                      <li>대화 상자 내 다음 tabbable 요소로 초점 이동</li>
                      <li>마지막 tabbable 요소에 있는 경우 포커스를 대화상자 내 첫 번째 tabbable 요소로 이동</li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <th scope="row"><kbd>Shift</kbd> + <kbd>Tab</kbd></th>
                  <td>
                    <ul>
                      <li>대화 상자 내 이전 tabbable 요소로 초점 이동</li>
                      <li>첫 번째 tabbable 요소에 있는 경우 포커스를 대화상자 내 마지막 tabbable 요소로 이동</li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <th scope="row"><kbd>Esc</kbd></th>
                  <td>대화상자 닫기</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section>
          <h2>Reference</h2>
          <ul>
            <li><a href="https://labs.ssbbartgroup.com/index.php/ARIA_Dialog_Role" target="_blank">SSB BART group- ARIA Dialog Role</a></li>
            <li><a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" target="_blank">Dialog (Modal) Design Patterns - W3C</a></li>
          </ul>
        </section>
        <section>
          <p class="heading2">감사합니다</p>
          <p data-align="right">
            <a href="https://github.com/niawa/aoa">NIAW AOA Github</a> <br />
            publisher@publisher.name
          </p>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/prismjs/prism.min.js'}
				]
			});
		</script>
	</body>
</html>
